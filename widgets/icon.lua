local Addon = _G[...]local modName = ...local title = "Icons"local widget = Addon:NewWidget(title, 'Frame')widget.defaults = {	visibility = {		border = {			color = {				a = 0.5,				b = 0,				g = 0,				r = 0,			},			file = "Blizzard",			thickness = 10,		},		background = {			enable = false,			file = "Raid",			color = {				a = 0.5,				b = 0,				g = 0,				r = 0,			},		},	},	display = {		circle = {			offset = 0,			spin = -40,			spacing = 0,			enable = true,			rings = 1,		},		advanced = {			offset = 1,			zoom = 11,			scale = 136,			opacity = 30,			reverse = false,			spacing = -17,			enable = true,			fixed = false,			padding = 0,			auraTooltip = true,		},		position = {			y = 2,			x = -38,			frameLevel = 4,			anchor = "Right",			frameStrata = 4,		},		bar = {			columns = 8,			rows = 4,		},	},}	function widget:GetIcons()	if self and (self.TEST == true) then		return {			function(self)					return "Resting", "Interface\\CharacterFrame\\UI-StateIcon", {.05, .45, .07, 0.46}			end,			function(self)				return "Classification",  function(self, unit)					return "nameplates-icon-elite-gold", {0,1,0,1}, true				end			end,			function(self)					local index = 1;					local left, right, top, bottom;					local coordIncrement = RAID_TARGET_ICON_DIMENSION / RAID_TARGET_TEXTURE_DIMENSION;					left = mod(index , RAID_TARGET_TEXTURE_COLUMNS) * coordIncrement;					right = left + coordIncrement;					top = floor(index / RAID_TARGET_TEXTURE_ROWS) * coordIncrement;					bottom = top + coordIncrement;					return "Raid Target", "Interface\\TargetingFrame\\UI-RaidTargetingIcons", {left, right, top, bottom}			end,			function(self)				local factionGroup = UnitFactionGroup(self.owner.id);					return "PvP: FFA", "Interface\\TargetingFrame\\UI-PVP-FFA", {.1, .5, 0, .6}				 end,			function(self)				return "Leader", "Interface\\GroupFrame\\UI-Group-LeaderIcon", {0, 1, 0, 1}			end,			function(self)				return "Loot Master", "Interface\\GroupFrame\\UI-Group-MasterLooter", {0, 1, 0, 1}			end,			function(self)				local role = "TANK"				return "Role: "..role, "Interface\\LFGFrame\\UI-LFG-ICON-PORTRAITROLES", {GetTexCoordsForRoleSmallCircle(role)}			end,			function(self)					return "In Combat", "Interface\\CharacterFrame\\UI-StateIcon", {.5, 1, 0, 0.5}			end,			function(self)				return "High Level", "Interface\\TargetingFrame\\UI-TargetingFrame-Skull", {0, 1, 0, 1}			end,			function(self)				return "Quest", "Interface\\TargetingFrame\\PortraitQuestBadge", {0, 1, 0, 1}			end,			function(self)					return "Battle Pet", "Interface\\TargetingFrame\\PetBadge-"..PET_TYPE_SUFFIX[3], {0, 1, 0, 1}			end,		}		else		return {			function(self)				if ( UnitIsUnit(self.owner.id , "player") and IsResting() ) then					return "Resting", "Interface\\CharacterFrame\\UI-StateIcon", {.05, .45, .07, 0.46}				end			end,			function(self)				return "Classification", function(self, unit)					local classification = UnitClassification(unit);					local icon					if ( classification == "elite" or classification == "worldboss" ) then						icon = ("nameplates-icon-elite-gold");					elseif ( classification == "rareelite" ) then						icon = ("nameplates-icon-elite-silver");					end					 return icon, {0,1,0,1}, true				end			end,			function(self)				local index = GetRaidTargetIndex(self.owner.id);				if ( index ) then					index = index - 1;					local left, right, top, bottom;					local coordIncrement = RAID_TARGET_ICON_DIMENSION / RAID_TARGET_TEXTURE_DIMENSION;					left = mod(index , RAID_TARGET_TEXTURE_COLUMNS) * coordIncrement;					right = left + coordIncrement;					top = floor(index / RAID_TARGET_TEXTURE_ROWS) * coordIncrement;					bottom = top + coordIncrement;					return "Raid Target", "Interface\\TargetingFrame\\UI-RaidTargetingIcons", {left, right, top, bottom}				end			end,			function(self)				local factionGroup = UnitFactionGroup(self.owner.id);				if ( UnitIsPVPFreeForAll(self.owner.id) ) then					return "PvP: FFA", "Interface\\TargetingFrame\\UI-PVP-FFA", {.1, .5, 0, .6}				elseif ( factionGroup and factionGroup ~= "Neutral" and UnitIsPVP(self.owner.id) ) then					return "PvP", "Interface\\TargetingFrame\\UI-PVP-"..factionGroup, {.025, .6, .025, .6}				end			end,			function(self)				if ( UnitIsGroupLeader(self.owner.id) ) then					if ( HasLFGRestrictions() ) then						return "Guide", "Interface\\LFGFrame\\UI-LFG-ICON-PORTRAITROLES", {0, 0.296875, 0.015625, 0.3125}					else						return "Leader", "Interface\\GroupFrame\\UI-Group-LeaderIcon", {0, 1, 0, 1}					end				end			end,			function(self)				local lootMethod				local lootMaster				lootMethod, lootMaster = GetLootMethod()				if ( lootMaster == 0 and IsInGroup() ) then					return "Loot Master", "Interface\\GroupFrame\\UI-Group-MasterLooter", {0, 1, 0, 1}				end			end,			function(self)				local role = UnitGroupRolesAssigned(self.owner.id)				if ( role == "TANK" or role == "HEALER" or role == "DAMAGER") then					return "Role: "..role, "Interface\\LFGFrame\\UI-LFG-ICON-PORTRAITROLES", {GetTexCoordsForRoleSmallCircle(role)}				end			end,			function(self)				if (UnitAffectingCombat(self.owner.id)) then					return "In Combat", "Interface\\CharacterFrame\\UI-StateIcon", {.5, 1, 0, 0.5}				end			end,			function(self)				local targetLevel = UnitLevel(self.owner.id)				if (not  UnitIsCorpse(self.owner.id)) and (not ( targetLevel > 0 )) and (not ( UnitIsWildBattlePet(self.owner.id) and UnitIsBattlePetCompanion(self.owner.id)))  then					return "High Level", "Interface\\TargetingFrame\\UI-TargetingFrame-Skull", {0, 1, 0, 1}				end			end,			function(self)				if (UnitIsQuestBoss(self.owner.id)) then					return "Quest", "Interface\\TargetingFrame\\PortraitQuestBadge", {0, 1, 0, 1}				end			end,			function(self)				if ( UnitIsWildBattlePet(self.owner.id) or UnitIsBattlePetCompanion(self.owner.id) ) then					local petType = UnitBattlePetType(self.owner.id)					return "Battle Pet", "Interface\\TargetingFrame\\PetBadge-"..PET_TYPE_SUFFIX[petType], {0, 1, 0, 1}				end			end,		}	endendfunction widget:New(parent)		local opac = CreateFrame('Frame', nil, parent.box)--opacity control	local bar = self:Bind(CreateFrame('StatusBar', nil, opac))	bar:SetAllPoints(opac)	bar.owner = parent	bar.opac = opac	bar.drop = bar.drop or CreateFrame('Frame', nil, bar)	bar.drop:SetAllPoints(bar)	bar.center = CreateFrame("Frame", nil, bar)	bar.center:SetSize(20, 20)	bar.center:SetPoint("Center", bar)	return barendfunction widget:Load()	self:EnableMouse(false)	self.id = self.owner.id	self.icons = self.icons or {}	self.total = self.total or 0endfunction widget:Layout()	if self.sets.display.advanced.enable~= true then		self:Hide()		self.noUpdate = true		return	else		self:Show()		self.noUpdate = nil	end	self:Show()	self:ResizeBar()	self:ResizeRound()	self:Reposition()		self:SetVisibility()		self:Update()endfunction widget:ResizeBar()	local icons = self.sets.display.bar	-- if icons.enable == true  then		-- self.sets.display.circle.enable = nil	-- else		-- self.sets.display.circle.enable = true		-- return	-- end		local adv = self.sets.display.advanced	local columns = icons.columns	local icons = self:GetIcons()	local rows =  ceil(#icons / columns)	local space = adv.spacing	local width, height	for i = 1, 11 do		local icon = self:GetOrCreateIcon(i)	end	local width, height = self.icons[1]:GetSize()			width, height =  width + space,  height + space	local barWidth = (width * columns) - space	local barHeight = (height * rows) - space		self.opac:SetSize(barWidth, barHeight)	local isLeftToRight = adv.isLeftToRight	local isTopToBottom = adv.isTopToBottom		for i, icon in pairs(self.icons) do		local col, row = (columns-1) - (i-1) % columns, rows - ceil(i / columns)		if isLeftToRight ~= true then			col = (i-1) % columns		end		if isTopToBottom ~= true  then			row = ceil(i / columns) - 1		end		icon:ClearAllPoints()		icon:SetPoint('TOPLEFT', width*col, -(height*row))		icon:Show()	end		self.opac:SetScale(adv.scale/100)	self.opac:SetAlpha(adv.opacity)		self.drop:ClearAllPoints()		local t = adv.padding/2		self.drop:SetPoint("TopLeft", -t, t)	self.drop:SetPoint("BottomRight", t, -t)endfunction widget:ResizeRound()		local circle = self.sets.display.circle	-- if circle.enable == true then		-- self.sets.display.bar.enable = nil	-- else		-- self.sets.display.bar.enable = true		-- return	-- end	local adv = self.sets.display.advanced		local spin = (circle.spin) + 17	local space = adv.spacing + 9		if not circle.enable then		return	end		local numButtons = #self.icons	local cols = numButtons	local rows = 1	local isLeftToRight = adv.isLeftToRight	local isTopToBottom = adv.isTopToBottom	local size = 5 * (adv.scale/100)	-- grab base button sizes	local l, r, t, b = 0,0,0,0	local bW, bH = self.icons[1]:GetSize()	local pW, pH = 0,0	local diameter =  math.sqrt((bW^2) + (bH^2)) + space			local left, right, top, bottom	local base = 360/numButtons	local circumference = (diameter * numButtons) / (math.pi)	local left, right, top, bottom	for i, button in ipairs(self.icons) do		i = (numButtons +1) - i		local row = 1		row = 0		local angle = -(.5*base-1) + (base*i)				angle = math.rad(angle - spin)		local u = (circumference/2)-- + self.sets.height		local v = (circumference/2)-- + self.sets.width		local y, x = math.cos(angle)*u, -math.sin(angle)*v		if isTopToBottom ~= true then			y= -y		end		if isLeftToRight ~= true then			x = -x		end		if (left and x < left) or (not left) then			left = x		end		if (right and x > right) or (not right) then			right = x		end		if (bottom and y < bottom) or (not bottom) then			bottom = y		end		if (top and y > top) or (not top) then			top = y		end		button:ClearAllPoints()		button:SetPoint("Center", self.center, "Center", x , y)	end	diameter = (diameter/2) - 7.45	local w, h = (diameter*2) - left + right, (diameter*2) - bottom + top	self:SetSize( w + (pW*2) - space, h + (pH*2) - space)	local x, y = (w/2) - (right + diameter) , (h/2) - (top + diameter)	self.center:SetPoint("Center", self, x, y)endfunction widget:Reposition()	local position = self.sets.display.position	local scale = self.sets.display.advanced.scale/100	self.opac:ClearAllPoints()	self.opac:SetPoint(position.anchor, self.opac:GetParent(), position.x / scale, position.y / scale)		local lay = Addon.layers[position.frameStrata]	self:SetFrameStrata(lay)	self:SetFrameLevel(position.frameLevel)	endfunction widget:SetIcons()	local icons = self.sets.display.icons	endfunction widget:SetVisibility()	local visibility = self.sets.visibility	local background = visibility.background	local border = visibility.border	local pad = background.padding		local BG = self:GetMediaPath("statusbar", background.file)	local brd = self:GetMediaPath("border", border.file)		if not background.enable then		BG = ""	end	if not border.enable then		brd = ""	end	self.drop:SetBackdrop({ 		bgFile = BG, 		edgeFile = brd,		tile = false,		edgeSize = border.thickness, 		insets = { left = pad, right = pad, top = pad, bottom = pad }	})	do		local color = background.color		self.drop:SetBackdropBorderColor(color.r, color.g, color.b, color.a)	end	do		local color = background.color		self.drop:SetBackdropColor(color.r, color.g, color.b, color.a)	endendfunction widget:Update()	if self.noUpdate then		return	end	if self.OnUpdate then		self:OnUpdate()	endendfunction widget:GetMediaPath(kind, fileName)	if Addon.lib then		return Addon.lib:Fetch(kind, fileName)	endendfunction widget:OnUpdate(elapsed)	if self.noUpdate then		return	end	self:DisplayOrder()endlocal used = 0function widget:DisplayOrder()	local adv = self.sets.display.advanced	local icons = self.sets.display.bar	for i, icon in pairs(self.icons) do --clear any unused icons.		self:ClearIcon(icon)	end	local statusIcons = self:GetIcons()		local j = 0	used = 0	for i, info in pairs(statusIcons) do		local name, image, coords, index, atlas = info(self)		if type(image) == "function" then			image, coords, atlas = image(self, self.owner.id)		end		if (not adv.fixed) and image then			j = j +1			i = j		end				if not adv.reverse then			i = (#statusIcons +1) - i		end				local offset = adv.offset - 1				local i = (i - offset)				if offset > 11 then			i = i - 11		end				if i < 1 then			i = 11 + i		end		if image then		self:SetIcon(i, name, image, coords, index, atlas)		end	end	--self:ClearUnusedIcons()endfunction widget:GetOrCreateIcon(i)	local t = self.icons[i] or self:CreateTexture(nil, 'ARTWORK')	if not self.icons[i] then		self.icons[i] = t		t:SetSize(15, 15)		t.isShown = nil		t.index = i		if not t.empty then			t.empty = true		end	end	return tendfunction widget:SetIcon(i, name, image, coords, index, atlas)	if i and image then		used = used + 1		local icon = self:GetOrCreateIcon(i)		if atlas then			icon:SetAtlas(image)		else			icon:SetTexture(image)		end		icon:SetTexCoord(unpack(coords))		icon:Show()		icon.empty = nil	endendfunction widget:ClearUnusedIcons()	--if not self.sets.display.advanced.fixed then		for i = used + 1, #self.icons do	--		self:ClearIcon(self.icons[i])		end	--endendfunction widget:ClearIcon(icon)	if (not icon.empty) then --don't clear if it's already clear.		icon.lastIcon = nil		icon:SetTexture("")		icon:SetTexCoord(0,1,0,1)		icon.isShown = nil		if MouseIsOver(icon) then			self.hasMouse = nil			self.lastMouse = nil		end		icon.empty = true	endendwidget.Options = {	{		name = "Display",		kind = "Panel",		key = "display",		panel = "Display",		options = {			{				name = 'Enable Bar',				kind = 'CheckButton',				key = 'disable',				panel = "bar",			},			{				name = 'Columns',				kind = 'Slider',				key = 'columns',				min = 1,				max = 11,				panel = 'bar',			},									{				name = 'Enable Circle',				kind = 'CheckButton',				key = 'enable',				panel = "circle",			},			{				name = 'Rings',				kind = 'Slider',				key = 'rings',				min = 1,				max = 11,				panel = 'circle',			},			{				name = 'Spin',				kind = 'Slider',				key = 'spin',				min = -180,				max = 180,				panel = 'circle',			},			{				name = 'Offset',				kind = 'Slider',				key = 'offset',				min = 0,				max = 180,				panel = 'circle',			},			{				name = 'Spacing',				kind = 'Slider',				key = 'spacing',				min = -32,				max = 32,				panel = 'circle',			},			{				name = 'X Offset',				kind = 'Slider',				key = 'x',				panel = 'position',				min = -400,				max = 400,			},			{				name = 'Y Offset',				kind = 'Slider',				key = 'y',				panel = 'position',				min = -400,				max = 400,			},			{				name = "Frame Level",				kind = "Slider",				key = "frameLevel",				min = 1,				max = 100,				panel = 'position',			},			{				name = "Frame Strata",				kind = "Slider",				key = "frameStrata",				min = 1,				max = 8,				panel = 'position',			},			{				name = 'Anchor',				kind = 'Menu',				key = 'anchor',				panel = 'position',				table = {					'TopLeft',					'Top',					'TopRight',					'Right',					'BottomRight',					'Bottom',					'BottomLeft',					'Left',					'Center',				},			},			{				name = 'Scale',				kind = 'Slider',				key = 'scale',				min = 25,				max = 200,				panel = 'advanced',			},						{				name = 'Disable',				kind = 'CheckButton',				key = 'disable',				panel = "advanced",			},			{				name = 'Reverse',				kind = 'CheckButton',				key = 'reverse',				panel = "advanced",			},			{				name = 'Offset',				kind = 'Slider',				key = 'offset',				min = 1,				max = 11,				panel = 'advanced',			},			{				name = 'Fixed',				kind = 'CheckButton',				key = 'fixed',				panel = "advanced",			},			{				name = 'Flip Up',				kind = 'CheckButton',				key = 'isTopToBottom',				panel = "advanced",			},			{				name = 'Flip Left',				kind = 'CheckButton',				key = 'isLeftToRight',				panel = "advanced",			},			{				name = 'Spacing',				kind = 'Slider',				key = 'spacing',				min = -32,				max = 32,				panel = 'advanced',			},			{				name = 'Opacity',				kind = 'Slider',				key = 'opacity',				min = 0,				max = 30,				panel = 'advanced',			},			{				name = 'Padding',				kind = 'Slider',				key = 'padding',				panel = "advanced",				min = -13,				max = 32,			},			{				kind = "Button",				name = "Test Mode",				handler = "icons",				func = function(owner)					owner.TEST = not owner.TEST					owner:Layout()				end,				panel = "advanced",			},		}	},		{		name = "visibility",		kind = "Panel",		key = "visibility",		panel = "visibility",		options = {						{				name = 'Enable',				kind = 'CheckButton',				key = 'enable',				panel = "background",			},			{				name = 'Texture',				kind = 'Media',				key = 'file',				mediaType = 'Statusbar',				panel = "background",			},			{				name = 'Background Color',				kind = 'ColorPicker',				key = 'color',				panel = 'background',			},									{				name = 'Texture',				kind = 'Media',				key = 'file',				mediaType = 'Border',				panel = "border",			},				{				name = 'Enable',				kind = 'CheckButton',				key = 'enable',				panel = "border",			},			{				name = 'Background Color',				kind = 'ColorPicker',				key = 'color',				panel = 'border',			},			{				name = 'Thickness',				kind = 'Slider',				key = 'thickness',				panel = "border",				min = 1,				max = 32,			},		}	},}--]]