local Addon = _G[...]local Llocal Menu = {}Addon.Menu = Menulocal function layout(page)page.HEIGHT = 0		for type, toggles in pairs(page.toggles) do		for i, piece in pairs(toggles) do			piece:Show()			piece:ClearAllPoints()			local P = toggles[i-1]			local y = -5			piece.type = type			if type == "slider" then				y = -15			end						piece:SetParent(page.leaf)			if type == "checkbutton" then				if toggles[i-1] then					piece:SetPoint("TopLeft", toggles[i-1], "BottomLeft", 0, y)				else					piece:SetPoint("TOPLEFT", page.leaf, 0, -3)					y = -3				end			else				if toggles[i-1] and toggles[i-1].type == "slider" then					piece:SetPoint("TopLeft", toggles[i-1], "BottomLeft", 0, y)				else					piece:SetPoint("TOPLEFT", page.upper, "BottomLeft", 0, y)				end			end			if type == "checkbutton" then				page.upper:SetPoint("Bottom", piece, 0,-15)			else				page.lower:SetPoint("Bottom", piece, 0,-15)			end						page.HEIGHT = page.HEIGHT + piece:GetHeight() - y		end	end		Dominos:GetOptions():Render(page)	endlocal layers = {	"BACKGROUND",	"LOW",	"MEDIUM",	"HIGH",	"DIALOG",	"FULLSCREEN",	"FULLSCREEN_DIALOG",	"TOOLTIP",}Addon.layers = layerslocal anchors = {	'TopLeft',	'Top',	'TopRight',	'Right',	'BottomRight',	'Bottom',	'BottomLeft',	'Left',	'Center',}Addon.anchors = anchorslocal function SetLayer(self)	local lay = layers[self.sets.frameStrata]	self:SetFrameStrata(lay)	self:SetFrameLevel(self.sets.frameLayer)endfunction Menu:NewTab(key)	self.panelSelector:AddPanel(key)	local panel = Dominos:GetOptions().Panel:New(self)	panel.Hide()		panel.container = panel	panel.owner = self.owner	panel.self = self	panel.tabs = {}		panel:SetScript('OnSizeChanged', function() Dominos:GetOptions():Render(panel) end)	panel:SetPoint('TopLeft', self, 'TopLeft', 0, -55)	panel:SetPoint('TopRight', self, 'TopRight', 25, -55)	panel:SetPoint('Bottom', self, 0, 0)	self.panels[key] = panel	function panel:SetOwner(owner)		self.owner = self.owner	end	return panelendlocal function PrepareOptions(opts)	local trace = {}	local options = {}	local d	local adv		if not opts then return end	for i , info in pairs(Addon.Copy(opts)) do		local title = string.lower(info.panel or i)		if not trace[title] then			trace[title] = {}			if (title == "basic") then				d = title				tinsert(options , 1, {title = title, info = trace[title]})			elseif (title == "advanced") then				adv = {title = title, info = trace["advanced"]}			else				d = d or title				tinsert(options, {title = title, info = trace[title]})			end		end		if adv then			tinsert(options, adv)		end		tinsert(trace[title], info)	end		return trace, options, dendlocal function GetRestrict(panel)	local allow = true	if panel.owner.GetRestrictions then		local id, include = panel.owner.GetRestrictions()		if (include == true) then			if id ~= string.lower(panel.owner.id) then				allow = false			end		elseif include == false then			if id == string.lower(panel.owner.id) then				allow = false			end		end	end	return allowendlocal Book = {}function Book:New(menu, key, options)	menu.panelSelector:AddPanel(key)	local book = Dominos:GetOptions().Panel:New(menu)			book:Hide()	book.key = key	book.menu = menu	book.container = book	Addon.Merge(Book, book)	book.id = key	book.owner = menu.owner	book:SetPoint("TopLeft")	book:SetPoint("BottomRight")	book.contents = book:NewContents()	book.pages = {}		menu.panels[key] = book	book.sets = menu.owner.sets[book.key]		return bookendfunction Book:NewChapter(id, options)	self.pages = self.pages or {}	if self.pages[id] then return self.pages[id] end		local page = CreateFrame("ScrollFrame", nil, self)	page:SetPoint("TopLeft", self.contents, "BottomLeft")	page:SetPoint("BottomRight")	page:SetPoint("TopLeft", self.contents, "BottomLeft")	page:SetPoint("BottomRight")	Addon.Merge(Book, page)	self.pages[id] = page	page:Hide()	page.id = id	page.pages = {}	page.parent = self	page.owner = self.owner	page.sets = self.sets[page.id]	page.title = self:NewIndex(id)	page.contents = page:NewContents()	local trace, p, d = PrepareOptions(options)				for i, info in pairs(options) do		local trace, p, d = PrepareOptions(info.options)			for i, b in pairs(p) do			page:NewPage(b.title, b.info)		end				page:SetPage(d)			end	return pageendfunction Book:GetMaxScroll()	return math.max(self.HEIGHT, self:GetHeight()) - self:GetHeight()endfunction Book:SetScroll(value)	self:SetVerticalScroll(value)endfunction Book:OnMouseWheel(delta)	self.scroll = self.scroll - (delta * 25)	local n = 0	local x = math.max(self.leaf.scrollManager:GetHeight(), self:GetHeight()) - self:GetHeight()	if self.scroll < n then		self.scroll = n	end	if self.scroll > x then		self.scroll = x	end	self.leaf.scrollBar:SetValue(self.scroll)endfunction Book:NewPage(id, options)	if self.pages[id] then return self.pages[id] end	local page = CreateFrame("ScrollFrame", nil, self)	page:SetPoint("TopLeft", self.contents, "BottomLeft")	page:SetPoint("BottomRight", -15, 0)	Addon.Merge(Book, page)	Addon.Merge(Menu, page)	self.pages[id] = page	page.parent = self	page:Hide()	page.id = id	page.title = self:NewIndex(id)	page.owner = self.owner	page.sets = self.sets[id]	page.height = page.height or page:GetHeight()	page.width = page.width or page:GetWidth()		page.leaf = CreateFrame("Frame", nil, page)	page.leaf.scrollManager = page.leaf:CreateTexture(nil, "OVERLAY")	page.leaf.scrollManager:SetColorTexture(0,0,0,.25)	page:SetScrollChild(page.leaf)	page.leaf:SetPoint("Left")	page.leaf:SetSize(10,10)	page.scroll = 0	page.upper = CreateFrame("Frame", nil, page.leaf)	page.upper:SetSize(10, 10)	page.upper:SetPoint("Top", page.leaf, 0,0)		page.lower = CreateFrame("Frame", nil, page.leaf)	page.lower:SetSize(10, 10)	page.lower:SetPoint("Top", page.upper, "Bottom")	page.leaf.scrollManager:SetPoint("Top", page.upper)	page.leaf.scrollManager:SetPoint("Bottom", page.lower)		local scrollBar = CreateFrame('Slider', nil, self)	scrollBar:EnableMouseWheel(true)	local bg = scrollBar:CreateTexture(nil, 'BACKGROUND')	bg:SetColorTexture(0.3, 0.3, 0.3, 0.5)	bg:SetAllPoints(scrollBar)	local tt = scrollBar:CreateTexture(nil, 'OVERLAY')	tt:SetColorTexture(0, 0, 0, 1)	tt:SetSize(15, 15)	scrollBar:SetThumbTexture(tt)	scrollBar:EnableMouseWheel(true)	scrollBar:SetScript('OnMouseWheel', function(_,delta)		page:OnMouseWheel(delta)	end)	scrollBar:SetOrientation("VERTICAL")	scrollBar:Hide()	scrollBar:SetScript('OnValueChanged', function(_,value)		page:SetScroll(scrollBar:GetValue())	end)		page.leaf.scrollBar = scrollBar		page:SetScript("OnShow", function()		page:SetVerticalScroll(0)		local _max = page:GetMaxScroll()				if _max <= 0 then			scrollBar:Hide()			page:SetPoint("BottomRight", 0, 0)		else			scrollBar:Show()			page:SetPoint("BottomRight", -15, 0)				end				scrollBar:SetMinMaxValues(0, _max)		scrollBar:SetValue(0)	end)		scrollBar:SetPoint("TopLeft", page, "TopRight")	scrollBar:SetPoint("BottomLeft", page, "BottomRight")	scrollBar:SetWidth(15)		page:SetScript("OnMouseWheel", page.OnMouseWheel)	page.toggles = {}	page.Layout = function()		self.owner:Layout()	end	for name, option in pairs(options) do		local func = Menu[option.kind]		if func then			local o, type = func(page, option)			if o then				page.toggles[type] = page.toggles[type] or {}				tinsert(page.toggles[type], o)			end		end	end	layout(page)	return pageendfunction Book:Layout()	self.HEIGHT = 0		for type, toggles in pairs(self.toggles) do		for i, piece in pairs(toggles) do			piece:Show()			piece:ClearAllPoints()			local P = toggles[i-1]			local y = -5			piece.type = type			if type == "slider" then				y = -25			end						piece:SetParent(self.leaf)			if type == "checkbutton" then				if toggles[i-1] then					piece:SetPoint("TopLeft", toggles[i-1], "BottomLeft", 0, y)				else					piece:SetPoint("TOPLEFT", self.leaf, 0, -3)					y = -3				end			else				if toggles[i-1] and toggles[i-1].type == "slider" then					piece:SetPoint("TopLeft", toggles[i-1], "BottomLeft", 0, y)				else					piece:SetPoint("TOPLEFT", self.upper, "BottomLeft", 0, y)				end			end			if type == "checkbutton" then				self.upper:SetPoint("Bottom", piece, 0,-15)			else				self.lower:SetPoint("Bottom", piece, 0,-15)			end						self.HEIGHT = self.HEIGHT + piece:GetHeight() - y		end	end		Dominos:GetOptions():Render(self)endfunction Book:SetPage(id)	if self.pages[id] then		for i, page in pairs(self.pages) do			if i ~= id then				page:Hide()				page.title:UnlockHighlight()			end		end		self.pages[id]:Show()		self.pages[id].title:LockHighlight()	endendfunction Book:NewContents()	local contents = CreateFrame("ScrollFrame",nil, self)	contents:SetPoint("TopRight", 0, 0)	contents:SetPoint("TopLeft", 0, 0)	self.contents = contents	contents.prevWidth = 0	contents:SetHeight(20)	contents.scroll = 0	contents.titles = {}	self.pages = {}	contents.leaf = CreateFrame("Frame", nil, contents)	contents.leaf.scrollManager = contents.leaf:CreateTexture(nil, "OVERLAY")	contents.leaf.scrollManager:SetPoint("TopLeft")	contents:SetScrollChild(contents.leaf)	contents.leaf:SetPoint("Left")	contents.leaf:SetSize(15,15)	contents.highlight = contents:CreateTexture(nil, "OVERLAY")	contents.highlight:SetColorTexture(0.2, 0.2, 0.2, 0.5)	contents.highlight:SetAllPoints(contents)	contents:SetScript("OnMouseWheel", function(_, delta)		local _max = max(contents:GetWidth(), contents.leaf.scrollManager:GetWidth()) - contents:GetWidth()		local scroll = contents.scroll - (delta)				if not contents.titles[scroll] then			return		end				local n = 1		local x = #contents.titles				if scroll < n then			scroll = n		end		if scroll > x then			scroll = x		end		local e = contents.titles[scroll].Edge				if e > _max then			e = _max		else			contents.scroll = scroll		end				contents:SetHorizontalScroll(e)	end)	contents:SetScript("OnShow", function()		contents:GetScript("OnMouseWheel")(nil, 0)	end)		return contentsendfunction Book:NewIndex(id)	self.titleIndex = self.titleIndex or 1	local contents = self.contents	local title = CreateFrame("Button", nil, contents.leaf)	title:SetText(id)	title:SetNormalFontObject("GameFontNormal")	title:SetDisabledFontObject("GameFontHighlight")	title:SetHighlightFontObject("GameFontHighlight")	title.width = title:GetTextWidth() + 10	title:SetSize(title.width, 20)	local highlight = title:CreateTexture()	highlight:SetColorTexture(1, 1, 1, 0.5)	highlight:SetPoint('BOTTOMRIGHT', title, 'BOTTOMRIGHT')	highlight:SetPoint('BOTTOMLEFT', title, 'BOTTOMLEFT')	highlight:SetHeight(1)	title:SetHighlightTexture(highlight)	tinsert(contents.titles, title)	title:SetScript("OnClick", function()		self:SetPage(id)	end)	if contents.leaf.prevTitle then		title:SetPoint("Left", contents.leaf.prevTitle, "Right")	else		title:SetPoint("Left", contents.leaf)	end	contents.leaf.scrollManager:SetPoint("Right", title) 	contents.leaf.prevTitle = title			contents.prevWidth = contents.prevWidth + title.width	local i = self.titleIndex		local value = contents.prevWidth - title.width		local _max = max(contents.leaf.scrollManager:GetWidth(), contents:GetWidth()) + contents:GetWidth()		if _max ~= 0 and value > _max then		value = _max	end		title.Edge = value	self.titleIndex = self.titleIndex + 1		return titleendfunction Book:AddSeparator()	separator = self.leaf:CreateTexture(nil, "OVERLAY")	separator:SetColorTexture(random(0, 100) / 100,random(0, 100) / 100,random(0, 100) / 100,.5)	separator:SetSize(self:GetWidth(),random(1, 25))		if self.leaf.lastseparator then		separator:SetPoint("Top", self.leaf.lastseparator , "Bottom", 0 , -6)	else		separator:SetPoint("Top")	end		self.leaf.scrollManager:SetPoint("Bottom", separator)		self.leaf.lastseparator  = separatorend do	local Addon =  Dominos:GetOptions()	 	function Book:NewCheckButton(options)		options.parent = self		local button = Addon.CheckButton:New(options)		local prev = self.lastWidget		if prev then			button:SetPoint('TOP', self.lastWidget, 'BOTTOM', 0, -2)		else			button:SetPoint('TOPLEFT', 0, -2)		end		local width, height = button:GetEffectiveSize()		--self.height = self.height + (height + 4)		--self.width = max(self.width, width)		self.lastWidget = button		return button	end	function Book:NewSlider(options)		options.parent = self		local slider = Addon.Slider:New(options)		local prev = self.lastWidget		if prev then			slider:SetPoint('TOPLEFT', self.lastWidget, 'BOTTOMLEFT', 0, -(12 + slider.text:GetHeight()))		else			slider:SetPoint('TOPLEFT', 4, -(12 + slider.text:GetHeight()))		end		local width, height = slider:GetEffectiveSize()		self.height = self.height or self:GetHeight()		self.width = self.width or self:GetWidth()		self.height = self.height + (height + 12)		self.width = math.max(self.width, width)		self.lastWidget = slider		return slider	end	function Book:NewDropdown(options)		options.parent = self		local dropdown = Addon.Dropdown:New(options)		local prev = self.lastWidget		if prev then			dropdown:SetPoint('TOPLEFT', self.lastWidget, 'BOTTOMLEFT', 0, -4)		else			dropdown:SetPoint('TOPLEFT', 4, -4)		end		dropdown:SetPoint('RIGHT')		local width, height = dropdown:GetEffectiveSize()		self.height = self.height + (height + 4)		self.width = math.max(self.width, width)		self.lastWidget = dropdown		return dropdown	end	function Book:NewTextureSelector(options)		options.parent = self		local dropdown = Addon.Dropdown:New(options)		local prev = self.lastWidget		if prev then			dropdown:SetPoint('TOPLEFT', self.lastWidget, 'BOTTOMLEFT', 0, -2)		else			dropdown:SetPoint('TOPLEFT', 0, -2)		end		dropdown:SetPoint('RIGHT')		local width, height = dropdown:GetEffectiveSize()		self.height = self.height + (height + 2)		self.width = math.max(self.width, width)		self.lastWidget = dropdown		return dropdown	end	function Book:NewTextInput(options)		options.parent = self		local textInput = Addon.TextInput:New(options)		local prev = self.lastWidget		if prev then			textInput:SetPoint('TOPLEFT', self.lastWidget, 'BOTTOMLEFT', 0, -6)		else			textInput:SetPoint('TOPLEFT', 0, -6)		end		if options.width then			textInput:SetWidth(options.width)		else			textInput:SetPoint('RIGHT')		end		textInput:SetHeight(options.height)		local width, height = textInput:GetEffectiveSize()		self.height = self.height + (height + 6)		self.width = math.max(self.width, width)		self.lastWidget = textInput		return textInput	end	function Book:SetOwner(owner)		self.owner = owner	end	function Book:GetOwner()		return self.owner	end		local MIN_WIDTH = 276	local MIN_HEIGHT = 330		function Book:OnRender()		self:SetSize(max(self.width, MIN_WIDTH), max(self.height, MIN_HEIGHT))	end	endfunction Menu.NewMenu(self, menu, key, opts, test)	if self.owner.id == nil then		return	end	menu.owner = self.owner	menu.id = self.owner.id	local key = string.lower(key)		local panel = menu.panels[key]	if not panel then		panel = Book:New(menu, key, options)				panel:SetScript('OnSizeChanged', function() Dominos:GetOptions():Render(panel) end)		panel:SetPoint('TopLeft', menu, 'TopLeft', 0, -55)		panel:SetPoint('TopRight', menu, 'TopRight', 25, -55)		panel:SetPoint('Bottom', menu, 0, 0)				function panel:SetOwner(owner)			self.owner = menu.owner		end	end		local trace, p, d = PrepareOptions(opts)		if not p then return end	for i, options in pairs(p) do		local options = Addon.Copy(options)		local allow = GetRestrict(panel)		if allow then			local page = panel:NewChapter(options.title, options.info)			page.key = key		end	end	panel:SetPage(d)enddo	local function Panel(self, opts)		self.AddTab = Tab.NewTab		local key = string.lower(opts.name)		local panel = self:AddTab(key, opts)		if not panel then return end		panel.ShowTab = Tab.ShowTab		panel.sets = self.owner.sets[self.id][key]		function panel:Layout()			panel.owner[self:GetParent().id]:Layout()		end				local trace, p, d = PrepareOptions(opts.options)		panel._tabs = panel._tabs or {}		for i, options in pairs(p) do			local options = Addon.Copy(options)			local allow = GetRestrict(panel)			if allow then				if not panel._tabs[options.title] then					local tab = panel:NewTab(options.title, options.opts)					tab.sets = panel.sets[string.lower(options.title)]					function tab:Layout()						panel:Layout()					end					tab.id = self.id					tab.owner = panel					for name, option in pairs(options.info) do						local func = Menu[option.kind]						if func then							local o, type = func(tab, option)							if o then								tab.toggles[type] = tab.toggles[type] or {}								tinsert(tab.toggles[type], o)							end						end					end					--layout(tab)					panel._tabs[options.title] = tab				end			end		end		panel:ShowTab(d)		--]]	end		Menu.Panel = Panelend--Widgetslocal function Merge(source, destination, looped, blackList)	destination = destination or {}	if not source then		return destination	end	for key, value in pairs(CopyTable(source)) do		if (type(value) == 'table') then			if type(key) == "number" then				local index = #destination + 1				destination[index] = Merge(value, destination[index], true, blackList)			else				destination[key] = Merge(value, destination[key], true, blackList)			end		else			if (not looped) and (blackList and blackList[key]) then							else				destination[key] = value			end			end	end	return destinationendlocal valueButton = {}--[[	replaces the slider with a more functional and streamlined button.	all input mirrors a normal slider. Also includes EditBox.		~if a valueButton is displayed 			with no set value(SetValue),			valueButton picks the 50% value			between min and max. if no min 			or max is set, will create it's 			own.--]]do	function valueButton:New(parent, displayID)		local button = Merge(valueButton, CreateFrame("Frame", nil, parent))		button:SetSize(65, 20)		button:SetPoint("Center")						button.text = CreateFrame("EditBox", nil, button)		button.text:SetFont("Fonts\\FRIZQT__.TTF", 10, "OUTLINE, MONOCHROME")		button.text:SetPoint("Top")		button.text:SetPoint("Bottom", 0, 5)		button.text:EnableMouse(false)		button.text:SetAutoFocus(nil)		button.text:SetJustifyV("MIDDLE")		button.text:SetJustifyH("CENTER")				button.title = button:CreateFontString(nil, "ARTWORK")		button.title:SetFont("Fonts\\FRIZQT__.TTF", 10, "OUTLINE, MONOCHROME")		button.title:SetPoint("Left", button, "Right", 5, 0)				button.title:SetJustifyV("MIDDLE")		button.title:SetJustifyH("LEFT")		button.title:SetText(displayID)				button.plus = button:CreateTexture(nil, "BACKGROUND")		button.plus:SetTexture([[Interface\addons\Dominos_Units\textures\slider\plus]])		button.plus:SetPoint("TopRight")		button.plus:SetSize(10,10)		button.minus = button:CreateTexture(nil, "ARTWORK")		button.minus:SetTexture([[Interface\addons\Dominos_Units\textures\slider\minus]])		button.minus:SetPoint("TopLeft")		button.minus:SetSize(10,10)		button.text:SetPoint("Left", button.minus, "Right")		button.text:SetPoint("Right", button.plus, "Left")				button.underline = button:CreateTexture(nil, "ARTWORK")		button.underline:SetPoint("BottomLeft", button, 7.5, 2.5)		button.underline:SetPoint("BottomRight", button, -7.5, 2.5)		button.underline:SetHeight(3)		button.underline:SetColorTexture(1, 1, 1, .5)					button.knob = button:CreateTexture(nil, "ARTWORK")		button.knob:SetSize(5,5)		button.knob:SetColorTexture(0, 1, 0, 1)		button.text:SetPoint("Bottom", button.knob, "Top")				button:SetScript("OnShow", self.OnShow)				button:SetScript("OnMouseWheel", function(self, delta)			self:SetValue(self.value + (self:GetStepValue() * delta))		end)				button.text:SetScript("OnTextChanged", function(self)			local t = tonumber(self:GetText()) or 0			button:SetKnob(t)		end)				button.text:SetScript("OnEnterPressed", function(self)			if not tonumber(self:GetText()) then				button:update()				self:SetFocus()			else				button:SetValue(tonumber(self:GetText()))			end		end)				button.text:SetScript("OnEscapePressed", function(self)			self:ClearFocus()			self:SetText(button.value)		end)						button.text:SetScript("OnEditFocusGained", function(self)			self:HighlightText()		end)				button:SetScript("OnMouseDown",function(self)			if MouseIsOver(self.underline) then				self:Click(2, self.underline, 1)				return			end			if MouseIsOver(self.plus) then				self:Click(1, self.plus, 1)				return			end			if MouseIsOver(self.minus) then				self:Click(1, self.minus, -1)				return			end			if MouseIsOver(self.text) then				self:Click(3, self.text)							end		end)				button:SetScript("OnMouseUp",function(self)			self:Click()		end)				button.bg = button:CreateTexture(nil, "BACKGROUND")		button.bg:SetPoint("Top")		button.bg:SetPoint("Bottom", button.knob)		button.bg:SetPoint("Right", button.title)		button.bg:SetPoint("Left", button.underline)		button.bg:SetColorTexture(0, 0, 0, 1)				button.spacing = 10		return button, "slider"	end	function valueButton:OnShow()		if not self.widthSet then			self.widthSet = 1			self.title:SetWidth(200)		end		local n,x = self:GetMinMaxValues()					if self.value then	--		return		end						--local range = n + ((x - n)/2)			--	self:update(nil,  )				if self.get then			self:SetValue(self:get(self))		else			self:SetValue(n + ((x - n)/2))		end	end		function valueButton:SetValue(value)		self.value = value		self:update(value)	end		function valueButton:GetValue()		return self.value	end		function valueButton:SetMinMaxValues(_min, _max)		local n, x = _min, _max		if n and x then			n, x = math.min(n, x), math.max(n, x)					end		self.min, self.max = n, x	end		function valueButton:GetMinMaxValues()		local style = "faux"		local _min,_max = self.min, self.max		local v = 999			if not _min then				self._min = self._min or max(-(math.abs(self.value  or 0) + 10) or -v, -v) 				if _max then					self._min = -_max				end				if self.value < self._min then					self._min          = max(-(math.abs(self.value or 0) + 10) or -v, -v)								end								_min = self._min			end			if not _max then				self._max = self._max or min((math.abs(self.value or 0) + 10) or v, v)				if _min then					self._max = -_min				end				if self.value or 0 > self._max then					self._max          = min((math.abs(self.value or 0) + 10) or v, v)				end				_max = self._max			end		return _min, _max, style	end	function valueButton:SetStepValue(value)		self.step = value or 1	end	function valueButton:GetStepValue()		return self.step or 1	end		function valueButton:PrepareToClick(func)		self.preparedToClick = func	end		function valueButton:Click(click, button, value)		if MouseIsOver(self) and click then			--dragging the slider with the mouse			if click == 2 then				self:SetScript("OnUpdate", function(self)					local cX = GetCursorPosition() /  UIParent:GetEffectiveScale()					local _min, _max = self:GetMinMaxValues()					local lX = button:GetLeft()					local w = button:GetRight() - lX					local cX = (cX -lX)					cX = math.max(cX, 0)					cX = math.min(cX, w)					local range = _max - _min										self:SetKnob(math.floor(_min + ((cX/w) * range)))					self.text:SetText(math.floor(_min + ((cX/w) * range)))					self.preparedToClick  =  function()						self:SetValue(math.floor(_min + ((cX/w) * range)))					end				end)			elseif click == 3 then				self.preparedToClick  = self.preparedToClick or function()					self.text:SetFocus()				end			else				--pressed one of the plus or minus buttons				local track, _time = self.value, 0				local _min, _max = self:GetMinMaxValues()				self:SetScript("OnUpdate", function(self)					_time = _time + 1					if _time > 5 then						_time = 0						if MouseIsOver(button)  then							track = track + value							if track>=_min and track<=_max then								self:SetKnob(track)								self.text:SetText(track)									self.preparedToClick  = function()									self:SetValue(track)									track = nil								end							end						end					end				end)			end		else			self:SetScript("OnUpdate", nil)		end				if self.preparedToClick then			self:preparedToClick()			self.preparedToClick = nil			self:SetScript("OnUpdate", nil)		end	end	function valueButton:update(value)		value = value or self.value or 0		self.text:ClearFocus()		if self.min and value then			if (value < self.min) then				value = self.min			end		end		if self.max and value  then			if(value > self.max) then				value = self.max			end		end		do			--faux limits, can't really foresee a need to 			--have values this big anywhere in Dominos.			local v = 999			if not value then return end			if(value > v) then				value = v			end			if(value < -v) then				value = -v			end		end		self.text:SetText(value)		self.value = value		self:SetKnob()		if self.set then			self:set(self,value)		end	end	function valueButton:SetKnob(X)		local width = self.underline:GetWidth()		local _min,_max, style = self:GetMinMaxValues()		local x = width * ((_max - (X or self.value or 0)) / (_max - _min))		if x < 0 then			x = 0		end		if x > width then			x = width		end		self.knob:SetPoint("Center", self.underline, "Right", -x, 0)				local g,r = 1 - (x/width), 0 + (x/width)				self.knob:SetColorTexture(r, g, 0, 1)				if x == 0 then			self.plus:Hide()		else			self.plus:Show()		end				if x == width then			self.minus:Hide()		else			self.minus:Show()		end		self.knobbing = true	--	self:UpdateMinMax()	endendlocal function GetValueButton(parent, info)	local b = valueButton:New(parent, info.name)	b:SetMinMaxValues(info.min, info.max)	b:SetStepValue(info.step)	b.set = info.set	b.get = info.get	b.type = "slider"	return b, "slider"enddo --Slider	local function Slider(panel, info)			local name, key, min, max, step = info.name, info.key, info.min, info.max, info.step		if min < 1 and min > 0 then			min = min * 100			max = max * 100		end		local owner = panel.owner		local sets = panel.sets				local slider =  panel:NewSlider{			name = name,			min = min,			max = max,			get = function(self) --Getter				if panel.sets then					return panel.sets[key] or max/2				else									return owner.sets[panel.key][key] or max/2				end			end,			set = function(self) --Setter				local val = ceil(self:GetValue())				if panel.sets then					if val ~= panel.sets[key] then						panel.sets[key] = val						panel:Layout()					end				else					owner.sets[panel.id][key] = val					owner:Layout()				end				return val			end,		}		slider.height = 25		slider:OnShow()		slider:Show()		return slider, "slider"	end	Menu.Slider = Sliderenddo --CheckButton	local function CheckButton(panel, info)				local owner = panel.owner		local name, key = info.name, info.key		local c = panel:NewCheckButton{			name = name,			get = function() 				if panel.sets then					return panel.sets[key]				else					return owner.sets[panel.id][key]				end			end,			set = function(self, enable)				local val = self:GetChecked()				if panel.sets then					if val ~= panel.sets[key] then						panel.sets[key] = val						panel:Layout()					end				else					owner.sets[panel.id][key] = val					owner:Layout()				end				return val			end		}		c.height = 28		return c, "checkbutton"	end	Menu.CheckButton = CheckButtonenddo --EditBox	local nextName = Addon:CreateNameGenerator("EditBox")	local function EditBox(p, info)		local name, key, setter = info.name, info.key, info.setter		local editBox = CreateFrame("EditBox", nextName(), p,  "InputBoxTemplate")		editBox:SetAutoFocus(false)		local set = CreateFrame("Button", editBox:GetName().."Set", editBox, "UIPanelButtonTemplate")		editBox.title = editBox:CreateFontString(nil, "OVERLAY", "GameFontNormalSmall")		editBox.title:SetPoint("Bottom", editBox, "Top")		local flip, flop = name, "Set"		local hold = false		local isLocked = false		local function flipText(why)			local text = flip			if why == "lock" then 				isLocked = true			elseif why == "unlock" then 				isLocked = false			end			if isLocked == true then				text = flop			else				text = flip			end			if (why == "OnEnter") then				if isLocked == true then					text = flip				else					text = flop				end			elseif (why == "OnLeave")  then				if isLocked == true then					text = flop				else					text = flip				end			end 			set:SetText(text)		end		set:SetScript("OnEnter", function(self)			flipText("OnEnter")		end)		set:SetScript("OnLeave", function(self)			flipText("OnLeave")		end)		local function setText(self)			if type(key) == "function" then				local value, title = key(p.owner)				self:SetText(value or "")				if title then					editBox.title:SetText(title)				end			else				self:SetText(p.owner.sets[p.id][key] or "")			end		end				editBox:SetScript("OnShow", function(self)			setText(self)		end)		editBox:SetScript("OnEscapePressed", function(self)			setText(self)			self:ClearFocus()		end)		editBox:SetScript("OnEnterPressed", function(self)			local text = self:GetText()			setter(p.owner, text ~= "" and text or nil)			setText(self)			self:ClearFocus()		end)		editBox:SetScript("OnEditFocusLost", function(self) self:HighlightText(0, 0) flipText("unlock") end)		editBox:SetScript("OnEditFocusGained", function(self) self:HighlightText() flipText("lock") end)		set:SetHeight(20)		set:SetText(name)		set:SetScript("OnClick", function(self)			editBox:GetScript("OnEnterPressed")(editBox)		end)		editBox.height = 30		editBox:SetSize(220, 30)		set:SetPoint("Left", editBox,"Right")		return editBox, "slider"	end	Menu.EditBox = EditBoxenddo --MediaPanel	local Master = Addon.master	local LibSharedMedia = Addon.lib	local NUM_ITEMS, WIDTH, HEIGHT, OFFSET = 8, 150, 20, 0	--[[ buttons ]]--	local mediaButton = Master:CreateClass('Button')	do		function mediaButton:New(parent)			local button = self:Bind(CreateFrame('Button', nil, parent))			button.BackDrop = CreateFrame("Frame",nil, button)			button.BackDrop:SetPoint("TopLeft", 50,-12)			button.BackDrop:SetPoint("BottomRight")									--button.BackDrop:SetFrameStrata("HIGH")						button:SetSize(285, HEIGHT + 12)			button:SetNormalFontObject('GameFontNormal')			button:SetHighlightFontObject('GameFontHighlight')			button:SetScript('OnEnter', function(self)				self:GetFontString():SetTextColor(1,1,1,1)			end)						button:SetScript('OnMouseWheel', function(self, direction)				local wheel = button:GetParent():GetScript("OnMouseWheel")				if wheel then					wheel(parent, direction)				end			end)			button:SetScript('OnLeave', function(self)				self:GetFontString():SetTextColor(1,1,0,1)			end)						button:SetScript("OnClick", function()				local txt = button:GetText()				if txt then					if parent.set then						parent.set(txt)						parent:Hide()					end				end			end)						--button:EnableMouse(false)			return button		end		function mediaButton:Set(mType, getFileName)			local fileName = getFileName()			local filePath = LibSharedMedia:Fetch(mType, fileName)			self:SetText(fileName)			if mType == 'border' then				self.BackDrop:SetBackdrop({					edgeFile = filePath,					edgeSize = 16,				})				self:SetNormalFontObject('GameFontNormal')			elseif (mType == 'background') or (mType == 'statusbar') or (mType == 'castborder') or (mType == 'overlay') then				self.BackDrop:SetBackdrop({					bgFile = filePath,					tile = false,				})				self:SetNormalFontObject('GameFontNormal')			end			local fs = self:GetFontString()			if fs then				if mType == 'font' then					fs:SetFont(filePath, 12)					self.BackDrop:SetBackdrop(nil)				else					fs:SetFont(LibSharedMedia:Fetch('font', 'Friz Quadrata TT'), 12)				end				fs:ClearAllPoints()				fs:SetJustifyH("LEFT")				fs:SetPoint("BottomLeft", self.BackDrop, "TopLeft")				fs:SetPoint("BottomRight", self.BackDrop, "TopRight")				fs:SetTextColor(1,1,0,1)			end						self.filepath = filePath			self:Show()		end	end	--[[ panel ]]--	local mediaPanel = Master:CreateClass('Frame')	do		local nextPanelName = Addon:CreateNameGenerator("MediaButton")		function mediaPanel:New(name, anchor)			local n = nextPanelName()			local panel = self:Bind(CreateFrame('Frame', n, anchor))								panel:SetBackdrop{			bgFile   = [[Interface\ChatFrame\ChatFrameBackground]],		}									panel:SetBackdropColor(0, 0, 0, 1)						panel:EnableMouse(true)			panel:SetFrameLevel(1000)			-- add close button			local closeButton = CreateFrame('Button', nil, panel)			closeButton:SetNormalFontObject('GameFontRedLarge')			closeButton:SetHighlightFontObject('GameFontHighlightLarge')			closeButton:SetText('×')			closeButton:SetSize(closeButton:GetFontString():GetSize())			closeButton:SetPoint('TOPRIGHT', panel, 0, 0)			closeButton:SetScript('OnClick', function() panel:Hide() end)			closeButton:SetFrameLevel(panel:GetFrameLevel() + 1)			panel.close = closeButton			-- add title text			panel.title = panel:CreateFontString(nil, 'OVERLAY', 'GameFontNormal')			panel.title:SetPoint('TOPLEFT', 15, -15)			panel:CreateScrollArea()						--add list buttons			panel:CreateButtons()			panel:SetScript('OnHide', function(self)				if self.holding then					self.holding:SetChecked(false)					self.holding:GetScript('OnShow')(self)					self.holding = nil				end			end)			-- make panel close on escape			tinsert(UISpecialFrames, panel:GetName())			return panel		end		function mediaPanel:CreateScrollArea()			self:SetScript('OnShow', function()				--self.buttons[1]:SetWidth(WIDTH)			end)			self:SetScript('OnHide', function()				--self.buttons[1]:SetWidth(WIDTH + 20)			end)			self:SetScript('OnMouseWheel', function(scroll, direction)				self:UpdateList(direction)			end)			self:SetScript('OnEnter', function()				self:SetScript('OnUpdate', function()					for i, button in pairs(self.buttons) do						if MouseIsOver(button) and button:IsShown() then							if not button.entered then								button.entered = true								button:GetScript('OnEnter')(button)							end						else							if button.entered then								button.entered = nil								button:GetScript('OnLeave')(button)							end						end					end				end)			end)			self:SetScript('OnLeave', function()				self:SetScript('OnUpdate', nil)			end)	--Convenient, but the mediaButton's need mouseover interaction.	-- [[		self:EnableMouse(false)		--[[			self:SetScript('OnMouseUp', function()				for i, button in pairs(self.buttons) do					if MouseIsOver(button) and button:IsShown() then						if self.set then							print(button:GetText())							self.set(button:GetText())							self:Hide()						end					end				end			end)	--]]		end		function mediaPanel:CreateButtons(mType)			self.buttons = self.buttons or {}			self.NUM_ITEMS = floor(self:GetParent():GetHeight()/20) - 2			self.HEIGHT = self:GetParent():GetHeight()				for i = 1, self.NUM_ITEMS do					if not self.buttons[i]then						local button = mediaButton:New(self)						if i == 1 then							button:SetPoint('TOPLEFT', -7, -36)						else							button:SetPoint('TOPLEFT', self.buttons[i - 1], 'BOTTOMLEFT', 0, -OFFSET)						end						tinsert(self.buttons, button)					end				end			for i,button in pairs(self.buttons) do				--self:SetFrameStrata("HIGH")				button:SetFrameLevel(100)				if i > self.NUM_ITEMS then					button:Hide()				else					button:Show()				end			end						end						function mediaPanel:UpdateList(direction)			local height, m = 20 + 12, 1						if self.mediatype == "overlay" then				height, m = 75 + 12, 0			end						local numButtons = floor(self:GetParent():GetHeight()/height) - m					direction = direction or 0			self.value = self.value  or 0			self.value = self.value - direction 			if self.value < 0 then				self.value = 0			elseif self.value > (#self.list -  numButtons) then				self.value = (#self.list -  numButtons)			end			for i = 1, numButtons do				local button = self.buttons[i]				local index = i + self.value				local filePath = LibSharedMedia:Fetch(self.mediatype, self.list[index])				button:Set(self.mediatype, function() return self.list[index] end)				button:SetHeight(height)			end		end	end	do		local Media = {}		function Media:Display(anchor, clicked, mediaType, get, set)			local panel = self:GetOrCreatePanel(anchor)			local holding = panel.holding			if holding then				holding:SetChecked(false)			end			if clicked and (holding == clicked) then				clicked:SetChecked(false)				panel.holding = nil				return panel:Hide()			end			panel.holding = clicked			clicked:SetChecked(true)			panel.owner = anchor.owner			panel:SetParent(anchor)			panel.title:SetText(mediaType)			panel:ClearAllPoints()			panel:SetPoint('TOPLEFT', anchor:GetParent(), 'TOPLEFT', 0, 0)			panel:SetPoint('BottomRight', anchor:GetParent(), 'BottomRight', 10, -15)			panel:SetParent(anchor:GetParent())			panel.mediatype = string.lower(mediaType)			--panel:SetFrameStrata("FULLSCREEN")			panel.list = LibSharedMedia:List(panel.mediatype)			panel.get = function() return anchor.owner[get](anchor.owner) end			panel.set = function(...) return anchor.owner[set](anchor.owner, ...) end			panel:CreateButtons()						panel:UpdateList()			panel:Show()						return panel		end		function Media:GetOrCreatePanel(anchor)			if not anchor.panel then				anchor.panel = mediaPanel:New(Addon.NAME..'MediaPanel', anchor)			end			return anchor.panel		end		local nextButtonName = Addon:CreateNameGenerator("MediaButton")		function Media:NewMediaButton(parent, name, mediaType, get, set)			local button = CreateFrame('CheckButton', nextButtonName(), parent)			button:SetHeight(20)			button.get = function() return parent.owner[get](parent.owner) end			button.set = function(...) return parent.owner[set](parent.owner, ...) end			button.preview = mediaButton:New(button)			button.preview:SetAllPoints(button)			button.preview:EnableMouse(false)			button:SetScript('OnClick', function()				self:Display(parent, button, mediaType, get, set)			end)			 button:SetScript('OnShow', function()				button.preview:Set(string.lower(mediaType), function() return button.get() end)				 button:SetWidth(275) --don't like this here, but it glitches otherwise. ~Goranaws			end)			--button:SetCheckedTexture(button:GetHighlightTexture():GetTexture())			button:SetText(name)						local  s = button:GetFontString()						button.Title = button:CreateFontString(nil, 'OVERLAY', 'GameFontNormal')			button.Title:SetPoint("Left")			button.Title:SetText(name)						s:ClearAllPoints()			s:SetPoint("TopLeft", button.Title, "TopRight")			s:SetPoint("TopRight")			--button:SetWidth(button:GetTextWidth()+8)			button:GetFontString():SetPoint("Left", button)			button.get = function()				return parent.owner[get](parent.owner)			end			button.set = function(...)				return parent.owner[set](parent.owner, ...)			end						local prev = parent.checkbutton --I'd like to call it parent.button instead, everywhere. ~Goranaws			if prev then				button:SetPoint('TOPLEFT', prev, 'BOTTOMLEFT', 0, -2)			else				button:SetPoint('TOPLEFT', 2, -2)			end			parent.checkbutton = button			parent.height = parent.height + 27			return button		end		Addon.MediaPanel = Media	endenddo --DropDownMenu	local nextName = Addon:CreateNameGenerator("DropDownMenu")	local function _Menu(panel, info)		local name, key, table, p = info.name, info.key, info.table, string.lower(info.panel or "")				local name, isColor, handler, func		if type(info) == "string" then			name = info		else			name, key, table = info.name, info.key, info.table		end				local owner = panel.owner				local button = CreateFrame("Button", nextName(), panel)		button:SetPoint("Left")		button:SetSize(265, 16)		button:SetNormalFontObject('GameFontNormalRight')		button:SetHighlightFontObject('GameFontHighlightRight')		button:SetBackdrop{			bgFile   = [[Interface\ChatFrame\ChatFrameBackground]],			insets   = {left = -2, right = -2, top = -2, bottom = -2},		}						button:SetHitRectInsets(-5, -5 , -7, -5)				button:SetBackdropColor(0.5, 0.5, 0.5, 0.2)		button:SetText(name or " ")		button.title = button:GetFontString() 		button.title:ClearAllPoints()		button.title:SetPoint("Left")				button.value = button:CreateFontString(button:GetName() .. "Text", "OVERLAY", "GameFontHighlightSmall")		button.value:SetPoint("Left", button.title, "Right")		button.value:SetPoint("Right")		button.value:SetJustifyH("Right")				button:SetScript("OnShow", function(self)			if self ~= button then				return			end			button:initialize()			local text			if panel.sets then				text = panel.sets[key]			else				text = owner.sets[panel.id][key]			end			button.value:SetText(text)		end)		button:SetScript("OnHide", function() L_CloseDropDownMenus() end)		button:SetScript("OnClick", function(self)			L_UIDropDownMenu_SetAnchor(button, 7, 6, "TopRight", button, "TopRight")			L_ToggleDropDownMenu(1, nil, button)			PlaySound(SOUNDKIT.U_CHAT_SCROLL_BUTTON)			button:SetSize(265, 16)		end)		function button:initialize(_, level)			local info = L_UIDropDownMenu_CreateInfo()			for i, value in ipairs(table) do				wipe(info)				info.text = value				info.func = function(item, name)					if panel.sets then						if name ~= panel.sets[key] then							panel.sets[key] = name							panel:Layout()						end					else						owner.sets[panel.id][key] = name						owner:Layout()					end					button.value:SetText(name)				end				local checked				if panel.sets then									checked = panel.sets[key]				else					checked = owner.sets[panel.id][key]				end				info.checked = (value == checked)				info.arg1 = value				L_UIDropDownMenu_AddButton(info)			end		end				button:SetFrameLevel(50)		local prev = panel.lastWidget		if prev then			button:SetPoint('TopLeft', panel.lastWidget, 'BottomLeft', 0, -3)		else			button:SetPoint('TOPLEFT', 0, -4)		end		panel.lastWidget = button		panel.height = panel.height + 26		button.height = 26		button.spacing = 5		return button , "checkbutton"	end	Menu.Menu = _Menuenddo--Button	local nextName = Addon:CreateNameGenerator("Button")	local function Button(panel, info)		local name, isColor, handler, func		if type(info) == "string" then			name = info		else			name, isColor, handler, func = info.name, info.isColor, info.handler, info.func		end				local owner = panel.owner				local b = CreateFrame("Button", nextName(), panel, "UIMenuButtonStretchTemplate")		b:SetSize(140, 25)		b:SetText(name or 1)		b.text = b:CreateFontString(nil, "ARTWORK", "GameFontNormal")		b.text:SetDrawLayer(BACKGROUND)		if isColor then			b.texture = b:CreateTexture(nil, "BACKGROUND")			b.texture:SetDrawLayer("BACKGROUND", -8)			b.texture:SetTexture("Interface\\Tooltips\\UI-Tooltip-Background")		else			b.texture = CreateFrame("Frame", b:GetName().."texture", b)			b.texture:SetFrameLevel(1)		end		b.text:SetDrawLayer("ARTWORK", 7)		if handler then			b:SetScript("OnClick", function()				func(owner[handler])			end)		end		b.texture:SetPoint("TopLeft", b, "BottomLeft")		b.texture:SetPoint("TopRight", b, "BottomRight")		b.texture:SetHeight(25)		b.text:SetAllPoints(b.texture)		panel.height = panel.height + 27		b.height = 27		local prev = panel.lastWidget		if prev then			b:SetPoint("TopLeft", panel.lastWidget, "BottomLeft", 0, -2)		else			b:SetPoint("TOPLEFT", 2, -2)		end		panel.lastWidget = b		return b, "checkbutton"	end	Menu.Button = Buttonenddo --ColorPicker(	local nextName = Addon:CreateNameGenerator("ColorPicker")	local function ShowColorPicker(r, g, b, a, changedCallback)		ColorPickerFrame.hasOpacity, ColorPickerFrame.opacity = nil, nil		ColorPickerFrame.func, ColorPickerFrame.opacityFunc, ColorPickerFrame.cancelFunc = nil, nil, nil		ColorPickerFrame:SetColorRGB(r,g,b)		ColorPickerFrame.hasOpacity, ColorPickerFrame.opacity = (a ~= nil), a		ColorPickerFrame.previousValues = {r,g,b,a}		ColorPickerFrame.func, ColorPickerFrame.opacityFunc, ColorPickerFrame.cancelFunc = changedCallback, changedCallback, changedCallback		ColorPickerFrame:Hide() -- Need to run the OnShow handler.		ColorPickerFrame:Show()	end	local function ColorPicker(panel, info) --this thing needs help.		local id, key = info.name,info.key		local button = CreateFrame("Button", nextName(), panel)		button:SetSize(24, 24)		button:SetHitRectInsets(0,-75,0,0)		local text = button:CreateFontString(nil, "OVERLAY", "GameFontNormal")		text:SetText(id)		text:SetPoint("Left", button, "Right", 5, 0)		local owner = panel.owner				button:SetPushedTexture("Interface\\Buttons\\UI-Quickslot-Depress")		button:SetHighlightTexture("Interface\\Buttons\\ButtonHilight-Square")		button:GetHighlightTexture():SetBlendMode("ADD")		button:SetNormalTexture("Interface\\\BUTTONS\\WHITE8X8")				local border = button:CreateTexture(nil, "OVERLAY")		border:SetAllPoints(button)		border:SetTexture("Interface\\BUTTONS\\UI-Quickslot2")		border:SetTexCoord(.2,.8,.2,.8)		button:SetScript("OnShow", function(self)			local saved				if panel.sets then					saved = panel.sets[key]				else					saved = owner.sets[panel.id][key]				end									if saved then				button:GetNormalTexture():SetVertexColor(saved.r, saved.g, saved.b, saved.a)			end		end)		button:SetScript("OnClick", function(self)			local saved			if panel.sets then				saved = panel.sets[key]			else			--	saved = owner.sets[panel.id][key]			end						local r, g, b, a = saved.r, saved.g, saved.b, saved.a			ShowColorPicker(r, g, b, a, function(restore)				local newR, newG, newB, newA				if restore then					newR, newG, newB, newA = unpack(restore)				else					newA, newR, newG, newB = OpacitySliderFrame:GetValue(), ColorPickerFrame:GetColorRGB()				end				saved.r, saved.g, saved.b, saved.a = newR, newG, newB, newA				self:GetScript("OnShow")(self)				owner:Layout()			end)			ColorPickerFrame:EnableKeyboard(nil)		end)		local prev = panel.lastWidget		if prev then			button:SetPoint("TopLeft",  prev, "BottomLeft", 0, -2)		else			button:SetPoint("TOPLEFT", 2, 0)		end		panel.lastWidget = button		panel.height = panel.height + 24		button.height = 24		button:Show()		return button , "checkbutton"	end	Menu.ColorPicker = ColorPickerenddo	--Media	local function Media(panel, info)--panel, "Background", "Background", "GetBackground", "SetBackground"		local name, key, handler, mediaType = info.name, info.key, info.handler, info.mediaType		if not  panel.owner then return end		local owner = panel.owner		local button = Addon.MediaPanel:NewMediaButton(panel, name, mediaType)		local handler = string.lower(panel.id)		button.get = function()							if panel.sets then					return panel.sets[key]				else					--return owner.sets[handler][key]				end				end		button.set = function(...)				if panel.sets then					if panel.sets[key] ~= ... then						panel.sets[key] = ...						panel:Layout()					end				else					--owner.sets[handler][key] = ...					owner:Layout()				end		end		local medi		button:SetScript("OnClick", function()				medi = Addon.MediaPanel:Display(panel, button, mediaType)				if medi and (medi.holding == button) then					medi.get = function() return button.get() end					medi.set = function(...) return button.set(...) end					medi:UpdateList()					medi:Show()				end			end)			button.height = 27			if string.lower(mediaType) == "overlay" then							button.height = 80			end						button:SetScript('OnMouseWheel', function(self, direction)				local wheel = button:GetParent():GetScript("OnMouseWheel")				if wheel then					wheel(panel, direction)				end			end)						panel.height = panel.height + (55)			panel.lastWidget = button									button:SetHeight(button.height)						button:Show()		return button , "checkbutton"	end	Menu.Media = Mediaendlocal files = {}local ShowMenu = function (panel, level)	if level == 1 then		files = Addon.Profiles.GetProfiles()		local info = L_UIDropDownMenu_CreateInfo()		for profile, settings in pairs(files) do			wipe(info)			info.text = profile			info.value = profile			info.keepShownOnClick = true			info.displayMode = "MENU"			info.hasArrow = 1			if profile == Dominos.db:GetCurrentProfile()then				info.checked = true			end			L_UIDropDownMenu_AddButton(info)		end	elseif (level == 2) and L_UIDROPDOWNMENU_MENU_VALUE then		local owner = panel.owner		if (not L_UIDROPDOWNMENU_MENU_VALUE) or not files then			return		end		local info = L_UIDropDownMenu_CreateInfo()		for id, layout in pairs(files[L_UIDROPDOWNMENU_MENU_VALUE]) do			wipe(info)			info.text = id			info.func = function()				local p = Addon.Merge(layout, owner.sets, nil, {x=1, y=1, point=1})				Addon.master.db.profile.frames[owner.id] = p				owner.sets = p				owner:Reload()				owner:Layout()				owner:Rescale()				owner:Reposition()				owner:Reanchor()			end			L_UIDropDownMenu_AddButton(info, 2, L_UIDROPDOWNMENU_MENU_VALUE)		end	end	endlocal function isLeftToRight(layout, looped)	for key, value in pairs(layout) do		if (not looped) and (type(value) == 'table') then			isLeftToRight(value, true) --don't modify top level settings, would alter frame position. 		elseif looped then			if type(value) == "table" then				isLeftToRight(value, true)			else							if (key == 'anchor')then					if string.find(value, 'Top') then						layout[key] = string.gsub (value, 'Top', 'Bottom')					elseif string.find(value, 'Bottom') then						layout[key] = string.gsub (value, 'Bottom', 'Top')					end				end				if key == "isTopToBottom" then					layout[key] = not value				end				 if (key == 'justifyV') then					if value == 1 then						layout[key] = 3					elseif  value == 3 then						layout[key] = 1					end				 end				if key == 'y' then					layout[key] = -value									end			end		end	endendlocal function FlipVertical(layout, looped)	for key, value in pairs(layout) do		if (not looped) and (type(value) == 'table') then			FlipVertical(value, true) --don't modify top level settings, would alter frame position. 		elseif looped then			if type(value) == "table" then				FlipVertical(value, true)			else								if (key == 'anchor')then					if string.find(value, 'Left') then						layout[key] = string.gsub (value, 'Left', 'Right')					elseif string.find(value, 'Right') then						layout[key] = string.gsub (value, 'Right', 'Left')					end				end								if key == "isLeftToRight" then					layout[key] = not value				end								if (key == 'justifyH') then					if value == 1 then						layout[key] = 3					elseif  value == 3 then						layout[key] = 1					end				end				if key == 'x' then					layout[key] = -value									end				if key == 'spin' then					layout[key] = -value									end				if key == 'spin' then					layout[key] = -value									end			end		end	endendAddon.FlipVertical = FlipVerticallocal function AddLayoutPanel(menu)	local panel = menu:NewPanel(L.Layout)	panel:NewSlider({		name = 'Height',		min = 10,		max = 600,		get = function(self) --Getter			return self:GetParent().owner.sets.height		end,		set = function(self) --Setter			self:GetParent().owner.sets.height = self:GetValue()			self:GetParent().owner:Layout()		end,	})	panel:NewSlider({		name = 'Width',		min = 10,		max = 600,		get = function(self) --Getter			return self:GetParent().owner.sets.width		end,		set = function(self) --Setter			self:GetParent().owner.sets.width = self:GetValue()			self:GetParent().owner:Layout()		end,	})	panel.paddingSlider = panel:NewPaddingSlider()	panel.scaleSlider = panel:NewScaleSlider()		panel.opacitySlider = panel:NewOpacitySlider()	panel.fadeSlider = panel:NewFadeSlider()			panel:NewCheckButton{			name = "Magic Width",			get = function(self) return panel.owner.sets.magicWidth end,			set = function(self, enable)				panel.owner.sets.magicWidth = self:GetChecked() or false				panel.owner:Layout()			end		}			return panelendlocal function AddAdvancedPanel(menu)	local panel = menu:NewPanel(L.Advanced)	panel:NewClickThroughCheckbox()	panel:NewShowInOverrideUICheckbox()	panel:NewShowInPetBattleUICheckbox()		local flipVert = Addon.Menu.Button(panel, 'Flip Vertical')	flipVert:SetScript('OnClick', function(self)		FlipVertical(panel.owner.sets)		panel.owner:Layout()	end)	local flipHori = Addon.Menu.Button(panel, 'Flip Horizontal')	flipHori:SetScript('OnClick', function(self)		isLeftToRight(panel.owner.sets)		panel.owner:Layout()	end)	panel:NewSlider({		name = 'Frame Layer',		min = 1,		max = 100,		get = function(self) --Getter			self:GetParent().owner.sets.frameLayer = self:GetParent().owner.sets.frameLayer or 4			return self:GetParent().owner.sets.frameLayer		end,		set = function(self) --Setter			self:GetParent().owner.sets.frameLayer = self:GetParent().owner.sets.frameLayer or 4			self:GetParent().owner.sets.frameLayer = self:GetValue()			self:GetParent().owner:Layout()		end,	})	panel:NewSlider({		name = 'Frame Strata',		min = 1,		max = 8,		get = function(self) --Getter			self:GetParent().owner.sets.frameStrata = self:GetParent().owner.sets.frameStrata or 4			return self:GetParent().owner.sets.frameStrata		end,		set = function(self) --Setter			self:GetParent().owner.sets.frameStrata = self:GetParent().owner.sets.frameStrata or 4			self:GetParent().owner.sets.frameStrata = self:GetValue()			self:GetParent().owner:Layout()		end,	})	local f =  Addon.Menu.Menu(panel, 'Copy', 'profile')	f:SetScript('OnShow', function(self)		if self ~= f then			return		end		f:initialize()	end)		function f:initialize(level, ...)		ShowMenu(panel, level)		f:SetSize(277, 16)	end	local b = Addon.Menu.Button(panel, 'Delete Frame')	b:SetScript('OnClick', function(self)		if not b.clicked then			b.clicked = true			b:SetText('Are you sure?')		else			Addon.master.db.profile.units.frames[panel.owner.id] = false			local frames = Addon.frames			if panel.owner then				panel.owner:Delete()			end			if LibStub and LibStub('LibKeyBound-1.0') then				LibStub('LibKeyBound-1.0'):Deactivate()			end			Addon.pauseDelay:ResetLock(1)		end	end)	local input = panel:NewTextInput{		name = L.ShowStates,		multiline = true,		width = 290,		height = 64,		get = function() return panel.owner:GetShowStates() end,		set = function(_, value) panel.owner:SetShowStates(value)  end	}		input.editBox:SetScript('OnEnterPressed', function(self) input:Save() self:ClearFocus() end)	return panelendfunction Addon:CreateMenu()	if not self.menu then		self.menu = self.master:NewMenu(self.id)		local panel = AddLayoutPanel(self.menu)		if self.widgets then			for i, b in pairs(self.widgets) do				if b.CreateMenu and self.Menu then					b:CreateMenu(self.menu)				end			end		end		AddAdvancedPanel(self.menu)	end	return self.menuendlocal menu, configfunction Addon:ShowMenu()	if not self.master:IsConfigAddonEnabled() then return end	config = config or LoadAddOn('Dominos_Config')	L = L or LibStub('AceLocale-3.0'):GetLocale('Dominos-Config')			local menu = self.menu or self:CreateMenu()		self.menu = menu		menu:Hide()		menu:SetOwner(self)		menu:ShowPanel(L.Layout)		menu:Show()end--[[local e = CreateFrame("Frame", "GorTestFrame", UIParent, "TranslucentFrameTemplate")e:SetSize(200, 300)e:SetPoint("Center")e:Hide()local b = Book:New(e, "Book")local chapter, pagefor i = 1, 40 do	chapter = b:NewChapter(i)	for i = 1, 40 do		page = chapter:NewPage("A "..i)		for i = 1, 50 do			page:AddSeparator()		end	end	chapter:SetPage("A 1")endb:SetPage(1)e:Show()--]]